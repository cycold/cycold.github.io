存储数字5 
5 --> 二进制 101
内存在需要存储5时,会首先在内存中开辟一片空间,
通常是开辟`8`个相邻的开关(形象的说法),但是实际上,5只需要`3`个开关就够了,
但是计算机规定,每一次最小是分配8位,所以5在内存中,实际上是,占用的8位
即:
`0000 0101`, 所以才有了`字节`这个定义, 即 1byte = 8 bit
这是之前的8位机器, 现在随着内存的增加,5这个整数(int)默认就为32位,如果没有指定数据类型的话,
占用4个字节:
`00000000 00000000 00000000 00000101`

以上只是最基本的,为了在计算机中存储,定义了 `原码`, `反码`, `补码`
`原码就是其二进制,但是最高位要去掉,它表示符号位`
比如 5 的原码: 
0 000 01 01, 最高位的 0 表示为正数, 实际上只有7位是数据位
所以一字节能表示的范围就是 `-128 ~ 0 ~ 127`

`正数的原码就是反码就是补码 三位一体`

-5 
-0b 101
1 000 0101 原码(最高位1表示符号-) 这是用一个字节表示-5的原码
1 000 00000000 0101 原码(最高位1表示符号-) 这是用2个字节表示-5的原码

问题:
```
+5 : 0000 0101  
    + 
-5 : 1000 0101 
他们相加不等于0. (-5 + 5 == 0)
也就是希望相加后得到: 0000 0000
```
为了解决不等于0 的问题, 计算机科学专家引入了`补码`来修复这个bug
为了得到补码,专家有引入了`反码`,引入反码就是为了得到补码
`正数的原码就是反码就是补码 三位一体`
`负数的反码就是其原码的符号位不变,其他位取反`
```
-5
1000 0101 原码
1111 1010 反码
1111 1011 补码 (反码 + 1)
```
现在:
```
-5 + 5 这么计算
1111 1011 (-5)
   +
0000 0101 (+5)
1 0000 0000 (最高位舍弃)
现在终于等于了0, 引入了补码就解决了这个bug
```
所以负数,实际在内存中是以补码的形式存储的.有由于正数的原反补三位一体
所以得出:
`内存中都是以补码的形式存储的`

先开辟空间,比如只能用8位存,
1   0000 0001 +
-1  1111 1111
0 1 0000 0000
由于只能存储的是8位,所以最高位舍弃了

问题:
```
既然内存中存储的都是补码,那我如果得到以内存中的数据,如何知道原来的数据呢?
比如 -5 1111 1011? 这里就是涉及到 补码如何得到原码, 因为我们把5放进去,
期望拿出来依然是5.
补码如何得到原码?
`对补码再求一次补码就得到了原码`
```
补码如何得到原码?
`对补码再求一次补码就得到了原码`;
