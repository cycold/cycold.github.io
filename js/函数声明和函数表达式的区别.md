看下面代码:
```js
var foo = function _foo() {
  console.log("Hello");
  console.log(_foo); //[Function: _foo]
  console.log(foo === _foo); //true
  console.log(foo.prototype.constructor === _foo); //true
}

foo();

//console.log(_foo) // ReferenceError: _foo is not defined

上面是一个函数表达式,为什么其函数名`_foo`是未定义的呢? 这和js的 `变量对象(VO)` 有关.
函数在调用时,主要是分为两个阶段的.
首先是创建一个变量对象(在堆中创建对象,堆中的对象属性是都需要先初始化的),
特别需要注意的是: 

我的理解:
因为函数名是唯一的,所以当函数定义好后,可以这么认为,此时会在堆中创建一个变量对象,
而且这个变量对象(VO)是一个单体(例)(唯一的变量),这个对象的属性就是函数里面声明的变量,函数,以及参数.
此时的VO有一个特点,就是所有的属性值都是初始值undefined,即没有赋值.这是函数在定义好之后的第一阶段
即在堆中创建一个VO单例(可以认为唯一的函数名指向这个单例,保证不会变成匿名对象),保存函数内的声明的变量,
声明的函数,以及参数并赋以默认值undefined.
之后,当函数执行时,就会创建一个当前的对象(AO,即和当前执行的上下文关联),这个AO继承(克隆)自那个单例(VO).
然后给这个AO中的属性赋值(此时开始执行函数中的赋值语句).所以VO只会创建一次,
而每次函数执行都会创建不同的AO,保证了每一次函数(即使递归调用自己)执行都会有不同的上下文(即不同的AO)

问题: 如果一个js文件中声明了3个函数a,b,c,其中只有a函数得到调用,b,c函数没有调用.
      请问此时堆中会有几个VO,几个AO?(假设程序还没有退出内存);

1. 当js文件被加载后,全局变量对象就会新增3个属性: a , b, c. 各自指向一个函数对象,
   此时在堆中已创建各自的VO,不管函数有没有被调用. 之后的每一次调用都是创建不同的调用AO,他继承自事先
   创建好的VO,然后开始执行赋值语句给AO中的属性赋值.函数结束后,释放AO,此时VO还在内存
   
2. 当js文件被加载后,全局变量对象就会新增3个属性: a , b, c. 各自指向一个函数对象,
   此时在堆中还没有创建各自的VO, 只有当调用函数时,才开始创建VO,并且这个VO只创建一次(单例),
   之后函数的每一次调用都创建一个AO,它继承自(clone)子这个VO,然后开始给这个AO中的属性赋值(执行赋值语句)
   函数结束后,释放AO,此时VO还在内存

3. 当js文件被加载后,全局变量对象就会新增3个属性: a , b, c. 各自指向一个函数对象,
   此时在在堆中还没有创建各自的VO, 只有当调用函数时,才开始创建VO,创建完后,开始创建AO,AO继承自VO
   之后函数的每一次调用又先创造VO,然后创造AO,然后开始给这个AO中的属性赋值(执行赋值语句)
   函数结束后,释放AO,此时VO还在内存

4. 其实AO很VO就是同一个对象.只是不同的执行阶段,叫法不同而已.
    比如在函数执行之前的阶段,即创建变量对象(初始化变量对象)阶段,此时的初始化的变量对象,我们把它叫做VO
        函数执行中,处理的这个VO对象,我们此时把它叫做AO
    没有什么继承(克隆)的关系,函数结束后,释放AO(VO)

个人觉得,js解析器会采用第1或者第2种方案(lexical 环境), 第二种方案更节约内存

chrome调试的结果来看,怎么感觉好像是第3种处理方案或者第4种处理方案


变量对象主要是将函数内的这些:
`变量声明`, `函数声明`, `函数参数`作为创建的变量对象的属性进行初始化(不管它的赋值语句,赋值语句是在执行阶段执行的)

这里有一个很重要的一点: 就是**表达式不会纳入其变量对象中.**

所以这里的函数表达式`_foo`就没有在当前上下文中的(变量对象/当前活动对象)AO中(这里为全局对象即AO)
也就是`_foo is not defined`
此时这里的函数表达式赋值给变量foo,当foo()调用时,开始创建基于_foo函数的上下文.
所以此时在_foo函数内部就可以访问到_foo了,此时的_foo是当前上下文中的变量对象的一个属性
当_foo执行完后,退出上下文,变量对象回收(如果没有闭包),此时在外面也就访问不到_foo了.

```
