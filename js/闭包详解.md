##### 本文带有很大的个人偏见在里面,只是一次对闭包的思考过程

```js 
function outer(arg1, arg2){
    var localOuter = 'outer';
    var localVar_1 = 1;
    var localVar_2 = 2;
    function inner_1(innerArg){

        var inner_local_1 = 0;

        localVar_1++;

        console.log(localVar_1);
        
        function inner__1(){
            inner_local_1 = '__';
            localVar_2 = '++';
        }
        inner__1()
    }
    function inner_2(){
        var inner_local_2 = 0;
        localVar_1++;
        console.log(localVar_1); 
    }
    inner_1();
    return inner_2;
}

//outer();  //2
//outer();  //2
//outer();  //2
var reserve = outer(); //2
    reserve();         //3
    reserve();         //4

var closure_1 = outer();
    closure_1();

var closure_2 = outer();
    closure_2();closure_2();closure_2();    

// outer函数执行(只分析作用域链) 其中AO===VO变量对象
```

```
/*
outer[[scope]] = 
[
    AO: {
            arg1: undefined
            arg2: undefined
            inner_1: inner_1(innerArg)
            inner_2: inner_2()
            localOuter: undefined
            localVar_1: undefined
            localVar_2: undefined
            this: Window
         },

    Global    
]

inner_1[[scope]] = 
[
    AO: {
            innerArg: undefined
            inner__1: inner__1()
            inner_local_1: undefined
            this: Window
        },
    Closure: {
        localVar_1: 1
        localVar_2: 2   
    },

    Global
]

inner_2[[scope]] = 
[
    AO: {
            innerArg: undefined
            inner__1: inner__1()
            inner_local_2: undefined
            this: Window
        },
    Closure: {
        localVar_1: 1
        localVar_2: 2   
    },

    Global
]


inner__1[[scope]] = 
[
    AO: {
            this: Window
        },
    Closure: {
        inner_local_1: 0
    },
    Closure: {
        localVar_1: 1
        localVar_2: 2   
    },

    Global
]


1.outer函数中定义的变量有三个 localOuter; localVar_1; localVar_2;
  发现只有被内部函数(不管是内部函数的函数)调用的变量才会进入一个闭包对象中.
2.闭包中的变量是处于同一级函数下定义的变量集合.比如inner__1函数的作用域链中就会有两个
  闭包对象,原因它调用了父函数以及父函数的父函数的变量
3.父函数只能形成一个闭包,子函数中的作用域链都指向同一个父函数的闭包
  子函数的修改,会互相的影响,因为这里只有当前的一个对象,所有的子函数中的
  作用域链都是对其的引用,所以会相互修改

所以说,函数的作用域链其实就是首先在当前变量对象中寻找,
没有就去父级中变量对象中寻找(就是这里出现了闭包,其实闭包就是父级变量对象的子集),然后父级的父级(父级的闭包的父级闭包)
(闭包应该在代码解析时,就已经优化(由js实现机制优化,比如不是自由变量的放入栈中运行,被子函数引用只能放入对象中)好了,
所以才是lexical(词法)上或者是静态的)

闭包的生命周期:
第一种: 
    直接运行函数: 
    outer();
    outer();
    outer();
这里直接运行3次,其实每一次运行outer完后,每一次都创建一个新的上下文,运行完后所有的上下文都退出了,
包括函数的[[scope]]中的对象的引用都断开了,此时,所有的作用域链上对象,比如AO,Closure都成了匿名对象了,
所以后面会被垃圾回收.除了全局的对象外.
关键是让闭包对象必能没有了对其的引用

第二种
   保存函数的返回值
   var  reserve = outer();  
        reserve();
        reserve();
   // outer函数返回了一个内部的 inner_2函数 而inner_2函数中的[[scope]]属性保存了对
   // 此次函数执行的一个闭包的引用,此时当outer函数执行退出后,其他的上下文消失了,但是此次执行的闭包
   // 通过返回的函数中的inner_2函数中的[[scope]]属性被引用到了外部的
   // 变量中,并且保存到全局的变量中,所以此时闭包的生命周期就和global一样长了.

   如果要将此闭包删除(使其回收),只要将 reserve = null; 或者 null = reserve 此时闭包就会没有引用值了
   飘向了茫茫内存之中,等待被回收
   当我么重复执行reserve();操作的都是内存中的同一个闭包对象
   这里可创造好多个不同的闭包:
   var closure_1 = outer();
       closure_1();

   var closure_2 = outer();
       closure_2();closure_2();closure_2();
   

其实函数中返回一个函数,不仅仅是返回一个函数,其实本质上了返回一个闭包对象.
返回了对内存中一个对象的引用(间接),但是由于是函数中作用域链上一个引用,
而函数的作用域链对程序是不可见(实现级别上),所以这里就只能通过函数
读取属性值,或者设置属性值(通过函数参数设置)了.这就间接的引入的一种封装的特征.

传递一个函数作为参数,其实可以说是传递了一个闭包,
因为函数有对闭包的引用.

所以才说,本质上将,理论上讲,js中的所有的函数都是闭包
作用域链上的VO,Closure,Global其实本质上都是一样,用于给标识符解析(变量查值用的)

不同的是其生命周期不同:
VO/AO 每一次的函数执行完后都会随着退出上下文而结束(包括递归调用)
Closure 既可以随着上下文的结束而结束,也可以通过函数返回得到保存.
Global 伴随着整个程序   


返回函数其实返回的是一个对象
将函数作为参数传递,其实可以说是传递函数中的[[scope]]属性
将函数作为参数传递进来,就可以通过这个函数中的作用域链寻找隐秘的数据了

在于不要让闭包垃圾回收机制回收

函数与函数之间的传递本质就是对象的传递
*/
```