为什么只包含头文件(里面只是函数声明而已),即可以得到定义的函数?

这个问题实际上是说，已知头文件"a.h"声明了一系列函数(仅有函数原型,没有函数实现)，
"b.cpp"中实现了这些函数，那么如果我想在"c.cpp"中使用"a.h"中声明的这些在"b.cpp"中实现的函数，
通常都是在"c.cpp"中使用#include "a.h",那么c.cpp是怎样找到b.cpp中的实现呢？

其实.cpp和.h文件名称没有任何直接关系，很多编译器都可以接受其他扩展名。

```
谭浩强老师的《C程序设计》一书中提到，编译器预处理时，要对#include命令进行"文件包含处理"：将headfile.h的全部内容复制到#include "headfile.h"处。
这也正说明了，为什么很多编译器并不care到底这个文件的后缀名是什么----因为#include预处理就是完成了一个"复制并插入代码"的工作。
程序编译的时候，并不会去找b.cpp文件中的函数实现，只有在link的时候才进行这个工作。
我们在b.cpp或c.cpp中用#include "a.h"实际上是引入相关声明，使得编译可以通过，程序并不关心实现是在哪里，是怎么实现的。
源文件编译后成生了目标文件（.o或.obj文件），目标文件中，这些函数和变量就视作一个个符号。在link的时候，
需要在makefile里面说明需要连接哪个.o或.obj文件（在这里是b.cpp生成的.o或.obj文件），此时，连接器会去这个.o或.obj文件中找在b.cpp中实现的函数，
再把他们build到makefile中指定的那个可以执行文件中。
```
（非常重要）

在VC中，一帮情况下不需要自己写makefile，只需要将需要的文件都包括在project中，VC会自动帮你把makefile写好。
通常，编译器会在每个.o或.obj文件中都去找一下所需要的符号，而不是只在某个文件中找或者说找到一个就不找了。
因此，如果在几个不同文件中实现了同一个函数，或者定义了同一个全局变量，链接的时候就会提示"redefined"