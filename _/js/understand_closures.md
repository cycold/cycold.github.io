##### closure(闭包)
闭包: 一个对象,保存某些变量.属于js作用域链(scope chain)的一部分
困惑: 为什么函数执行完后(当有内部函数调用变量),也就是出栈后,里面定义的局部变量居然没有释放(回收)??
条件: 函数的本地变量被其内部的函数使用时,此时就会形成一个闭包对象,里面保存被内部函数使用的变量值
试想: 
    函数本地变量没有被其他内部函数调用,那么函数出栈后,这些变量就会被释放;
    如果某些变量被内部函数调用呢?那外部函数出栈后,这些变量都被释放后,此时问题:
    那内部函数执行时(内部函数不确定具体的执行时间,有可能是10秒钟后执行呢),怎么
    得到之前调用的在外部函数中定义的变量呢?所以这里就不能释放这些变量,所以js就设计
    了闭包来解决这个问题.

```js
var age = 1
var name = 'baby'

function checkscope() {
  var age = 24
  var name = 'eric'
  var sex = 'male'
  return function() {
    console.log('age:', age)
    console.log('name:', name)
  }
}

var fun = checkscope();
// 这里的checkscope函数执行完后,变量age, name, sex都应该被回收的.
// 但是实际上,只有sex被回收了,而age,name没有被回收,why?
// 因为age,name此时还要被其他的函数调用,相当于这些变量还被占用着.还不能释放
// 这里粗略的来分析js的函数执行时的变量处理.
// 注意js的函数执行也是在栈里面,但是和c语言或者java语言不同的是
// js函数中定义的变量并没有保存在当前函数的栈里面.可以理解为栈里面保存的是一个
// 引用,指向一个对象,这个对象保存了所有的本地变量.所以根本上说:
// js的函数变量是保存在堆里面的,栈里面只是保存了所有的引用.
// 这也就说明了:在js中一切皆对象
// 而在c或者java的语言里面,函数中的变量是分别保存在当前函数的执行栈里面的.
// 出栈后,这些栈里面的变量自然就释放了.
// 而在js中是怎么释放变量的呢?
// 1.如果所有的变量都没有被内部函数调用
//      当函数执行完后,栈里面的引用自然就会释放,此时在堆里的变量对象就会没有了引用,之后就会被回收
// 2.如果有变量被内部函数调用
//      当函数执行完后, 假设栈里面的引用为 oj 指向 堆里面的变量对象 vj
//      oj --> vj
//      首先删除没有被占用的变量: delete oj.sex
//      保存这个引用oj到一个闭包中.形成闭包
//      然后函数退出


fun();
```