```java
class Test {
    public static void main(String[] args) {
        byte a = 4; 
        a = 7 + 3;

        // 为什么下面的会报错
        byte b = 5;
        byte c = 7;

        // 为什么下面的会报错?  // 报错:可能损失精度 找到int, 需要byte
        a = b + c


        // 实际上 byte a = 4; 编译器在内部就默认做了一次自动转换 因为 4 是int 常量 然后赋给类byte(-128~127) 的 a 编译器默认就做了转换
        // 可为什么 a = b + c 会报错呢? 注意: 这里的b和c都是变量, 其数值是不断变化的. 编译器无法确定其结果.
        // 因为 如果 b 变量的值变为 127, c变量的值如果变为55, 那么 b + c就会超过 a的值范围了.
        // 所以 b + c 的结果是变化的, 有可能刚好在 a的值范围中,也有可能相加的结果超过a的值范围 所以最终会导致丢失精度,编译器报错
        // 而上面的 a = 7 + 3 , 数值是确定的, 编译器可以100%确定最终的结果
        // 核心:就是编译器不确定 b + c的值是否符合 a的类型值范围. 也就是编译器不能确定结果 所以报错 这也就是java是非常严格的语言
        // 试想: 如果编译通过,那么就有可能在程序运行时,由于不断的改变b, c变量的值, 最终可能就会超过a的值范围,那么这明显就是不严格
        // 不准确的.所以编译器是一定不允许其通过的. 编译器是严格把关代码运行时可能出现的问题的,尽量把程序运行时潜在的问题给找出来

        // 再思考:下面的会不会报错?
        int x = 10;
        int x1 = 11;
        int x2 = 12;
        x = x1 + x2; 

        // 为什么以上的运算又不会报错呢? x1, x2也是变量值, 那么它们的运算也会超过 int类型的最大值? 而为什么编译器没有报错呢?

        // 故意超出
        int x3 = Integer.MAX_VALUE;
        x = 2 + x3; // 决定超出了int的最大值 , 但是编译器却不报错. 结果居然为最大值的负数

        // 这是因为int型的值是编译器的默认类型值,对于默认类型值, 如果其结果超出范围,在运行时就会自动舍弃掉
        // 最高位的值 最终变成负数 -Integer.MAX_VALUE 因为最高位为1(表示符号位)

    }
}
```
